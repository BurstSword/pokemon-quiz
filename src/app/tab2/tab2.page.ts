import { Component } from '@angular/core';
import { Option, Pokemon } from 'interfaces';

@Component({
  selector: 'app-tab2',
  templateUrl: 'tab2.page.html',
  styleUrls: ['tab2.page.scss']
})
export class Tab2Page {
  pokemons: Pokemon[] = [];
  pokemon: Pokemon = {} as Pokemon;
  visible: boolean = false;
  options: Option[] = [];
  pokemonTypes: boolean = false;

  pokemonTypesArray = [
    { type: 'Normal', image: '../../assets/pokemontypes/normal.webp' },
    { type: 'Fire', image: '../../assets/pokemontypes/fire.webp' },
    { type: 'Water', image: '../../assets/pokemontypes/water.webp' },
    { type: 'Electric', image: '../../assets/pokemontypes/electric.webp' },
    { type: 'Grass', image: '../../assets/pokemontypes/grass.webp' },
    { type: 'Ice', image: '../../assets/pokemontypes/ice.webp' },
    { type: 'Fighting', image: '../../assets/pokemontypes/fighting.webp' },
    { type: 'Poison', image: '../../assets/pokemontypes/poison.webp' },
    { type: 'Ground', image: '../../assets/pokemontypes/ground.webp' },
    { type: 'Flying', image: '../../assets/pokemontypes/flying.webp' },
    { type: 'Psychic', image: '../../assets/pokemontypes/psychic.webp' },
    { type: 'Bug', image: '../../assets/pokemontypes/bug.webp' },
    { type: 'Rock', image: '../../assets/pokemontypes/rock.webp' },
    { type: 'Ghost', image: '../../assets/pokemontypes/ghost.webp' },
    { type: 'Dragon', image: '../../assets/pokemontypes/dragon.webp' },
    { type: 'Dark', image: '../../assets/pokemontypes/dark.webp' },
    { type: 'Steel', image: '../../assets/pokemontypes/steel.webp' },
    { type: 'Fairy', image: '../../assets/pokemontypes/fairy.webp' },
  ];

  constructor() {
    this.retrievePokemons();
  }



  retrievePokemons() {
    getPokemons().then(pokemons => {
      this.pokemons = pokemons;
    }).finally(() => {
      const randomIndex = Math.floor(Math.random() * this.pokemons.length);
      this.pokemon = this.pokemons[randomIndex];
      this.generateOptions();
    });
  }

  selectRandomPokemon() {
    const randomIndex = Math.floor(Math.random() * this.pokemons.length);
    setTimeout(() => {
      this.pokemon = this.pokemons[randomIndex];
      this.pokemons.splice(randomIndex, 1);
      this.generateOptions();
      this.showPokemonAndName();
      if (this.pokemonTypes == true) {
        this.showPokemonTypes();
      }
    }, 300);
  }

  getImageStyle() {
    return {
      //this.image is the image URL that has been generated by your changeImage() function
      backgroundImage: `url(${this.pokemon.Image})`,
      //It's important to redefine the background position because it will not be used if no `backgroundImage` is provided 
      backgroundPosition: 'center center',
      backgroundRepeat: 'no-repeat',
      backgroundSize: 'cover'
    }
  }

  showPokemonAndName() {
    this.visible = !this.visible;
  }

  generateOptions() {
    this.options = [];
    this.options.push({ Name: this.pokemon.Name, Correct: true, Background: 'green' });
    for (let i = 0; i < 3; i++) {
      const randomIndex = Math.floor(Math.random() * this.pokemons.length);
      this.options.push({ Name: this.pokemons[randomIndex].Name, Correct: false, Background: 'red' });
    }
    this.options.sort(() => Math.random() - 0.5);
  }

  resolveOptions(option: Option, event: Event) {
    let buttons = document.getElementsByClassName('buttons') as HTMLCollectionOf<HTMLButtonElement>;
    for (let i = 0; i < buttons.length; i++) {
      buttons[i].disabled = true;
    }
    let correctOption = document.getElementById('optiontrue') as HTMLElement;
    this.showPokemonAndName();
    if (option.Correct) {
      if (event.target) {
        (event.target as HTMLElement).classList.remove('normalOption');
        (event.target as HTMLElement).classList.add('correctOption');
      }
      if(this.pokemonTypes==false){
        this.showPokemonTypes();
      }
    } else {
      if (event.target) {
        (event.target as HTMLElement).classList.add('incorrectOption');
      }
      if(this.pokemonTypes==false){
        this.showPokemonTypes();
      }
      correctOption.classList.remove('normalOption');
      correctOption.classList.add('correctOption');
    }
    setTimeout(() => {
      this.selectRandomPokemon();
    }, 800);
  }

  disableTwoIncorrectOptions() {
    let buttons = document.getElementsByClassName('buttons') as HTMLCollectionOf<HTMLButtonElement>;
    let count = 0;
    for (let i = 0; i < buttons.length; i++) {
      if (!this.options[i].Correct && count < 2) {
        buttons[i].classList.add('disabledOptions');
        count++;
      }
    }

  }

  showPokemonTypes() {
    this.pokemonTypes = !this.pokemonTypes;
  }

  getImageUrl(type: string) {
    const pokemonType = this.pokemonTypesArray.find(pokemonType => pokemonType.type === type);
    return pokemonType ? pokemonType.image : '';
  }
}

export async function getPokemons(): Promise<Pokemon[]> {
  const request = await fetch('./assets/pokemon.json')
  const data = await request.json()
  return data
}
